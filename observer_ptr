//  Ref. implementation from n3514

//  N4282: The World's Dumbest Smart Pointer (Walter E. Brown)

// ======================================================================
//
// observer_ptr: A pointer that is nearly oblivious to its pointee
//
// ======================================================================

#include <cstddef>      // nullptr_t
#include <functional>   // less
#include <type_traits>  // add_pointer, enable_if, ...
#include <utility>      // swap
#include <experimental/type_traits> // is_convertible_v

// ======================================================================
// interface:

namespace std
{

template<typename _Tp>
  class observer_ptr;

template<typename _Tp>
  void
  swap(observer_ptr<_Tp> &, observer_ptr<_Tp> &) noexcept;

template<typename _Tp>
  observer_ptr<_Tp>
  make_observer(_Tp *) noexcept;

template<typename _Tp, typename _Up>
  bool
  operator==(observer_ptr<_Tp> const &, observer_ptr<_Up> const &);

template<typename _Tp>
  bool
  operator==(observer_ptr<_Tp> const &, std::nullptr_t) noexcept;

template<typename _Tp, typename _Up>
  bool
  operator==(std::nullptr_t, observer_ptr<_Tp> const &) noexcept;

template<typename _Tp, typename _Up>
  bool
  operator!=(observer_ptr<_Tp> const &, observer_ptr<_Up> const &);

template<typename _Tp>
  bool
  operator!=(observer_ptr<_Tp> const &, std::nullptr_t) noexcept;

template< typename _Tp>
  bool
  operator!=(std::nullptr_t, observer_ptr<_Tp> const &) noexcept;

template<typename _Tp, typename _Up>
  bool
  operator<(observer_ptr<_Tp> const &, observer_ptr<_Up> const &);

template<typename _Tp, typename _Up>
  bool
  operator>(observer_ptr<_Tp> const &, observer_ptr<_Up> const &);

template<typename _Tp, typename _Up>
  bool
  operator<=(observer_ptr<_Tp> const &, observer_ptr<_Up> const &);

template<typename _Tp, typename _Up>
  bool
  operator>=(observer_ptr<_Tp> const &, observer_ptr<_Up> const &);

// hash support
template<typename _Tp>
  struct hash<observer_ptr<_Tp>>;

template<typename _Tp>
  class observer_ptr
  {
  public:

    // publish our template parameter and variations thereof:

    using element_type    = _Tp;
    using pointer         = std::add_pointer_t<_Tp>;
    using reference       = std::add_lvalue_reference_t<_Tp>;

  private:

    template<typename _Ptr>
      static constexpr bool
      _S_is_compat = std::is_convertible_v<std::add_pointer_t<_Ptr>, pointer>;

  public:

    // default constructor:
    constexpr
    observer_ptr() noexcept
    : _M_ptr{nullptr}
    { }

    // pointer-accepting constructors:
    constexpr
    observer_ptr(std::nullptr_t) noexcept
    : observer_ptr{}
    { }

    constexpr explicit
    observer_ptr(pointer __ptr) noexcept
    : _M_ptr{__ptr}
    { }

    template<typename _Tp2,
	     typename = std::enable_if_t<_S_is_compat<_Tp2>>>
      explicit
      observer_ptr(_Tp2 * __ptr) noexcept
      : _M_ptr{__ptr}
      { }

    // copying constructors (in addition to compiler-generated copy constructor):
    template<typename _Tp2,
	     typename = std::enable_if_t<_S_is_compat<_Tp2>>>
      observer_ptr(observer_ptr<_Tp2> const & __ptr) noexcept
      : _M_ptr{__ptr.get()}
      { }

    // copying assignments (in addition to compiler-generated copy assignment):

    template<typename _Tp2>
      std::enable_if_t<_S_is_compat<_Tp2>, observer_ptr &>
      operator=(observer_ptr<_Tp2> const & __ptr) noexcept
      {
        this->reset(__ptr.get());
        return *this;
      }

    // observers:
    constexpr pointer
    get() const noexcept
    { return this->_M_ptr; }

    constexpr reference
    operator*() const
    { return *this->get(); }

    constexpr pointer
    operator->() const noexcept
    { return this->get(); }

    constexpr explicit
    operator bool() const noexcept
    { return this->get(); }

    // conversions:
    constexpr explicit
    operator pointer() const noexcept
    { return this->get(); }

    // modifiers:
    constexpr pointer
    release() noexcept
    {
      pointer __old = this->get();
      this->reset();
      return __old;
    }

    constexpr void
    reset(pointer __ptr = nullptr) noexcept
    { this->_M_ptr = __ptr; }

    void
    swap(observer_ptr & __ptr) noexcept
    { std::swap(this->_M_ptr, __ptr._M_ptr); }

  private:

    pointer _M_ptr;

  };

  // -----------------------------------------------
  // non-member swap:

  template<typename _Tp>
    inline void
    swap(observer_ptr<_Tp> & __x, observer_ptr<_Tp> & __y) noexcept
    { __x.swap(__y); }

  // -----------------------------------------------
  // non-member make_observer:

  template<typename _Tp>
    observer_ptr<_Tp>
    make_observer(_Tp * __ptr) noexcept
    { return observer_ptr<_Tp>{__ptr}; }

  // -----------------------------------------------
  // non-member (in)equality comparison:

  template<typename _Tp, typename _Up>
    bool
    operator==(observer_ptr<_Tp> const & x, observer_ptr<_Up> const & __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp>
    bool
    operator==(observer_ptr<_Tp> const & __x, std::nullptr_t __y) noexcept
    { return __x.get() == __y; }

  template<typename _Tp>
    bool
    operator==(std::nullptr_t __x, observer_ptr<_Tp> const & __y) noexcept
    { return __x == __y.get(); }

  template<typename _Tp, typename _Up>
    bool
    operator!=(observer_ptr<_Tp> const & __x, observer_ptr<_Up> const & __y)
    { return ! operator==(__x, __y); }

  template<typename _Tp>
    bool
    operator!=(observer_ptr<_Tp> const & __x, std::nullptr_t __y) noexcept
    { return ! operator==(__x, __y); }

  template<typename _Tp>
    bool
    operator!=(std::nullptr_t __x, observer_ptr<_Tp> const & __y) noexcept
    { return ! operator==(__x, __y); }

  // -----------------------------------------------
  // non-member ordering:

  template<typename _Tp, typename _Up>
    bool
    operator<(observer_ptr<_Tp> const & __x, observer_ptr<_Up> const & __y)
    {
      using __pointer = typename observer_ptr<_Tp>::pointer;
      return std::less<__pointer>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Up>
    bool
    operator>(observer_ptr<_Tp> const & __x, observer_ptr<_Tp> const & __y)
    { return __y < __x; }

  template<typename _Tp, typename _Up>
    bool
    operator<=(observer_ptr<_Tp> const & __x, observer_ptr<_Tp> const & __y)
    { return ! (__y < __x); }

  template<typename _Tp, typename _Up>
    bool
    operator>=(observer_ptr<_Tp> const & __x, observer_ptr<_Tp> const & __y)
    { return ! (__x < __y); }

} // namespace std
