// N3905, Faster string searching (Boyer-Moore et al.)
/*
(c) Copyright Marshall Clow 2013.

Distributed under the Boost Software License, Version 1.0.
http://www.boost.org/LICENSE_1_0.txt
*/

#include <algorithm>
#include <exception>
#include <vector>
#include <array>
#include <unordered_map>
#include <cassert>
#include <type_traits>
#include <climits> // CHAR_BIT

namespace tba
{

  template<typename _Iter, typename _Searcher>
    _Iter
    search(_Iter __first, _Iter __last, const _Searcher &__searcher)
    { return __searcher(__first, __last); }

  template<typename _Iter,
	   typename _BinPred = typename std::equal_to<typename std::iterator_traits<_Iter>::value_type>>
    class default_searcher
    {

    public:

      default_searcher(_Iter __first, _Iter __last,
		       _BinPred __pred = _BinPred{})
      : _M_first{__first}, _M_last{__last}, _M_pred{__pred}
      { }

      template<typename _CorpIter>
	_CorpIter
	operator()(_CorpIter __cFirst, _CorpIter __cLast) const
	{ return std::search(__cFirst, __cLast, _M_first, _M_last, _M_pred); }

    private:

      _Iter _M_first;
      _Iter _M_last;
      _BinPred _M_pred;
    };


  //
  // Default implementations of the skip tables for B-M and B-M-H
  //
  template<typename _KeyTp, typename _ValueTp, typename _BinPred, bool /*__useArray*/>
    class _Skip_table;

  // General case for data searching other than bytes; use a map
  template<typename _KeyTp, typename _ValueTp, typename _BinPred>
    class _Skip_table<_KeyTp, _ValueTp, _BinPred, false>
    {

    private:

      const _ValueTp k_default_value;
      std::unordered_map<_KeyTp, _ValueTp, _BinPred> _M_skip;

    public:

      _Skip_table() = delete;
      _Skip_table(std::size_t patSize, _ValueTp default_value)
      : k_default_value{default_value}, _M_skip{patSize}
      { }

      void
      insert(_KeyTp __key, _ValueTp __val)
      {
	_M_skip[__key] = __val; // Would _M_skip.insert(val) be better here?
      }

      _ValueTp
      operator[](_KeyTp __key) const
      {
	auto __it = _M_skip.find(__key);
	return __it == _M_skip.end() ? k_default_value : __it->second;
      }
    };


    // Special case small numeric values; use an array
    template<typename _KeyTp, typename _ValueTp, typename _BinPred>
      class _Skip_table<_KeyTp, _ValueTp, _BinPred, true>
      {

      private:

	typedef typename std::make_unsigned<_KeyTp>::type _Unsigned_key_type;
	typedef std::array<_ValueTp, 1U << (CHAR_BIT * sizeof(_KeyTp))> _M_skipmap;
	_M_skipmap _M_skip;
	const _ValueTp k_default_value;

      public:

	_Skip_table(std::size_t /*__patSize*/, _ValueTp __default_value)
	: k_default_value{__default_value}
	{ std::fill_n(_M_skip.begin(), _M_skip.size(), __default_value); }

	void
	insert(_KeyTp __key, _ValueTp __val)
	{ _M_skip[static_cast<_Unsigned_key_type>(__key)] = __val; }

	_ValueTp
	operator[](_KeyTp __key) const
	{ return _M_skip[static_cast<_Unsigned_key_type>(__key)]; }
      };

    template<typename _Iter, typename _BinPred>
      struct _Boyer_Moore_traits
      {
	using _ValueTp = typename std::iterator_traits<_Iter>::difference_type;
	using _KeyTp = typename std::iterator_traits<_Iter>::value_type;
	typedef _Skip_table<_KeyTp, _ValueTp, _BinPred,
		std::is_integral<_KeyTp>::value && (sizeof(_KeyTp)==1)> _M_skiptable_t;
      };


    template <typename _FwdIter, typename _Hash, typename _BinPred>
    class boyer_moore_searcher
    {

      typedef typename std::iterator_traits<_FwdIter>::difference_type difference_type;
      typedef typename std::iterator_traits<_FwdIter>::value_type _ValueTp;

    public:

      boyer_moore_searcher(_FwdIter __first, _FwdIter __last,
			   _Hash __hash, _BinPred __pred)
      : _M_first{__first}, _M_last{__last},
	_M_hash{__hash}, _M_pred{__pred},
	k_pattern_length{std::distance(_M_first, _M_last)},
	_M_skip{k_pattern_length, _M_hash, _M_pred},
	_M_suffix{k_pattern_length + 1}
      {
	this->build_skiptable(_M_first, _M_last);
	this->build_suffix_table(_M_first, _M_last, _M_pred);
      }

      /// \fn operator(corpusIter corpus_first, corpusIter corpus_last)
      /// \brief Searches the corpus for the pattern that was passed into the constructor
      ///
      /// \param corpus_first The start of the data to search (Random Access Iterator)
      /// \param corpus_last One past the end of the data to search
      ///
      template<typename _RandIter>
	_RandIter
	operator()(_RandIter corpus_first, _RandIter corpus_last) const
	{
	  static_assert(std::is_same<
		  std::decay_t<typename std::iterator_traits<_FwdIter> ::value_type>,
		  std::decay_t<typename std::iterator_traits<_RandIter>::value_type>
		   >::value,
		  "Corpus and Pattern iterators must point to the same type" );

	  if (corpus_first == corpus_last)
	    return corpus_last; // if nothing to search, we didn't find it!
	  if (_M_first == _M_last)
	    return corpus_first; // empty pattern matches at start

	  const difference_type k_corpus_length = std::distance(corpus_first, corpus_last);
	  // If the pattern is larger than the corpus, we can't find it!
	  if (k_corpus_length < k_pattern_length)
	    return corpus_last;

	  // Do the search
	  return this->do_search(corpus_first, corpus_last);
	}

    private:

	_FwdIter _M_first;
	_FwdIter _M_last;
	_Hash _M_hash; // do I need this?
	_BinPred _M_pred; // I'm pretty sure I need this
	const difference_type k_pattern_length;
	std::unordered_map<_ValueTp, difference_type, _Hash, _BinPred> _M_skip;
	std::vector <difference_type> _M_suffix;

	/// \fn operator ( corpusIter corpus_first, corpusIter corpus_last, Pred p )
	/// \brief Searches the corpus for the pattern that was passed into the constructor
	///
	/// \param corpus_first The start of the data to search (Random Access Iterator)
	/// \param corpus_last One past the end of the data to search
	///
	template<typename corpusIter>
	  corpusIter
	  do_search(corpusIter __corpus_first, corpusIter __corpus_last) const
	  {
	    /* ---- Do the matching ---- */
	    corpusIter __curPos = __corpus_first;
	    const corpusIter __lastPos = __corpus_last - k_pattern_length;
	    difference_type __j, __k, __m;

	    while (__curPos <= __lastPos)
	    {
	      /* while (std::distance(__curPos, __corpus_last) >= k_pattern_length) { */
	      // Do we match right where we are?
	      __j = k_pattern_length;
	      while (_M_pred( _M_first[__j - 1], __curPos[__j - 1]))
	      {
		--__j;
		// We matched - we're done!
		if (__j == 0)
		  return __curPos;
	      }

	      // Since we didn't match, figure out how far to skip forward
	      // k = _M_skip[];
	      auto __it = _M_skip.find(__curPos[__j - 1]);
	      __k = __it == _M_skip.end() ? k_pattern_length : __it->second;

	      __m = __j - __k - 1;
	      if ( __k < __j && __m > _M_suffix[__j] )
		__curPos += __m;
	      else
		__curPos += _M_suffix[__j];
	      }

	      return __corpus_last; // We didn't find anything
	    }


	void
	build_skiptable(_FwdIter __first, _FwdIter __last)
	{
	  for (std::size_t __i = 0; __first != __last; ++__first, ++__i)
	    _M_skip[*__first] = __i;
	  //_M_skip.insert(*__first, __i);
	}


	template<typename _Iter, typename _Container>
	  void
	  compute_bm_prefix(_Iter __first, _Iter __last, _BinPred __pred,
			    _Container &__prefix)
	  {
	    const std::size_t __count = std::distance(__first, __last);
	    assert(__count > 0);
	    assert(__prefix.size() == __count);

	    __prefix[0] = 0;
	    std::size_t __k = 0;
	    for (std::size_t __i = 1; __i < __count; ++__i)
	    {
	      assert(__k < __count);
	      while (__k > 0 && !__pred(__first[__k], __first[__i]))
	      {
		assert(__k < __count);
		__k = __prefix[__k - 1];
	      }

	      if (__pred(__first[__k], __first[__i]))
		++__k;
	      __prefix[__i] = __k;
	    }
	  }

	void
	build_suffix_table(_FwdIter __first, _FwdIter __last, _BinPred __pred)
	{
	  const std::size_t __count = static_cast<std::size_t>(std::distance(__first, __last));

	  if (__count > 0)
	  { // empty pattern
	    std::vector<typename std::iterator_traits<_FwdIter>::value_type>
	      __reversed(__count);
	    std::reverse_copy(__first, __last, __reversed.begin());

	    std::vector<difference_type> __prefix(__count);
	    compute_bm_prefix(__first, __last, __pred, __prefix);

	    std::vector<difference_type> __prefix_reversed(__count);
	    compute_bm_prefix(__reversed.begin(), __reversed.end(),
			      __pred, __prefix_reversed);

	    for (std::size_t __i = 0; __i <= __count; ++__i)
	      _M_suffix[__i] = __count - __prefix[__count - 1];

	    for (std::size_t __i = 0; __i < __count; ++__i)
	    {
	      const std::size_t __j = __count - __prefix_reversed[__i];
	      const difference_type __k = __i - __prefix_reversed[__i] + 1;

	      if (_M_suffix[__j] > __k)
		_M_suffix[__j] = __k;
	    }
	  }
	}
    };

#if 0
    template <typename patIter, typename _BinPred = typename std::equal_to<typename std::iterator_traits<patIter>::value_type>, typename traits = _Boyer_Moore_traits<patIter, _BinPred>>
    class boyer_moore_horspool_searcher
    {
      typedef typename std::iterator_traits<patIter>::difference_type difference_type;
    public:
      boyer_moore_horspool_searcher ( patIter first, patIter last, _BinPred pred = _BinPred ())
      : _M_first{first}, _M_last{last}, _M_pred{pred},
	k_pattern_length{std::distance(_M_first, _M_last)},
	_M_skip{k_pattern_length, k_pattern_length}
      {
	std::size_t i = 0;
	if (_M_first != _M_last) // empty pattern?
	  for (patIter iter = _M_first; iter != _M_last-1; ++iter, ++i)
	    _M_skip.insert(*iter, k_pattern_length - 1 - i);
      }

      /// \fn operator ( corpusIter corpus_first, corpusIter corpus_last, Pred p )
      /// \brief Searches the corpus for the pattern that was passed into the constructor
      ///
      /// \param corpus_first The start of the data to search (Random Access Iterator)
      /// \param corpus_last One past the end of the data to search
      ///
      template<typename corpusIter>
	corpusIter
	operator()(corpusIter corpus_first, corpusIter corpus_last) const
	{
	  static_assert(std::is_same<
		  typename std::decay<typename std::iterator_traits<patIter> ::value_type>::type,
		  typename std::decay<typename std::iterator_traits<corpusIter>::value_type>::type
		   >::value,
		  "Corpus and Pattern iterators must point to the same type" );

	  if (corpus_first == corpus_last)
	    return corpus_last; // if nothing to search, we didn't find it!
	  if (_M_first == _M_last)
	    return corpus_first; // empty pattern matches at start

	  const difference_type k_corpus_length = std::distance(corpus_first, corpus_last);
	  // If the pattern is larger than the corpus, we can't find it!
	  if (k_corpus_length < k_pattern_length)
	    return corpus_last;

	  // Do the search
	  return this->do_search(corpus_first, corpus_last);
	}

    private:

      patIter _M_first, _M_last;
      _BinPred _M_pred;
      const difference_type k_pattern_length;
      typename traits::_M_skiptable_t _M_skip;

      /// \fn do_search ( corpusIter corpus_first, corpusIter corpus_last )
      /// \brief Searches the corpus for the pattern that was passed into the constructor
      ///
      /// \param corpus_first The start of the data to search (Random Access Iterator)
      /// \param corpus_last One past the end of the data to search
      ///
      template<typename corpusIter>
	corpusIter
	do_search(corpusIter corpus_first, corpusIter corpus_last) const
	{
	  corpusIter curPos = corpus_first;
	  const corpusIter lastPos = corpus_last - k_pattern_length;
	  while (curPos <= lastPos)
	  {
	    // Do we match right where we are?
	    std::size_t j = k_pattern_length - 1;
	    while (_M_pred(_M_first[j], curPos[j]))
	    {
	      // We matched - we're done!
	      if (j == 0)
		return curPos;
	      j--;
	    }

	    curPos += _M_skip[curPos[k_pattern_length - 1]];
	  }

	  return corpus_last;
	}
    };
#endif

template<typename _Iter,
  typename _BinPred = typename std::equal_to<typename std::iterator_traits<_Iter>::value_type>>
  default_searcher<_Iter, _BinPred>
  make_searcher(_Iter __first, _Iter __last, _BinPred __pred = _BinPred())
  {
    return default_searcher<_Iter, _BinPred>(__first, __last, __pred);
  }

template<typename _FwdIter,
	 typename _Hash = typename std::hash <typename std::iterator_traits<_FwdIter>::value_type>,
	 typename _BinPred = typename std::equal_to<typename std::iterator_traits<_FwdIter>::value_type>>
  boyer_moore_searcher<_FwdIter, _Hash, _BinPred>
  make_boyer_moore_searcher(_FwdIter __first,
			    _FwdIter __last,
			    _Hash __hash = _Hash(),
			    _BinPred __pred = _BinPred())
  {
    return boyer_moore_searcher<_FwdIter, _Hash, _BinPred>(__first, __last, __hash, __pred);
  }

#if 0
  template<typename _Iter,
	   typename _BinPred = typename std::equal_to<typename std::iterator_traits<_Iter>::value_type>,
	   typename _Traits = _Boyer_Moore_traits<_Iter, _BinPred>>
    boyer_moore_horspool_searcher<_Iter, _BinPred, _Traits>
    make_boyer_moore_horspool_searcher(_Iter __first, _Iter __last, _BinPred __pred = _BinPred())
    {
      return boyer_moore_horspool_searcher<_Iter, _BinPred, _Traits>(__first, __last, __pred);
    }
#endif
}
