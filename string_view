// Components for manipulating non-owning sequences of characters -*- C++ -*-

// Copyright (C) 2013 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/string_view
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 21  Strings library
//

#ifndef _GLIBCXX_STRING_VIEW
#define _GLIBCXX_STRING_VIEW 1

#pragma GCC system_header

#if __cplusplus <= 201103L
# include <bits/c++14_warning.h>
#else

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _CharT, typename _Traits = char_traits<_CharT>>
    class basic_string_view
    {

    public:

      // types
      using traits_type = _Traits;
      using value_type = _CharT;
      using pointer = const _CharT*;
      using const_pointer = const _CharT*;
      using reference = const _CharT&;
      using const_reference = const _CharT&;
      using const_iterator = implementation-defined; // See [string.view.iterators]
      using iterator = const_iterator;
      using const_reverse_iterator = std::reverse_iterator<const_iterator>;
      using reverse_iterator = const_reverse_iterator;
      using size_type = size_t;
      using difference_type = ptrdiff_t;
      static constexpr size_type npos = size_type(-1);

      // [string.view.cons], construct/copy
      constexpr
      basic_string_view() noexcept
      : _M_len{0}, _M_str{nullptr}
      { }

      constexpr basic_string_view(const basic_string_view&) noexcept = default;

      template<typename _Allocator>
        basic_string_view(const basic_string<_CharT, _Traits, _Allocator>& __str) noexcept
        : _M_len{__str.length()}, _M_str{__str.data()}
        { }

      constexpr basic_string_view(const _CharT* str)
      : _M_len{__builting_strlen(__str)}, _M_str{__str}
      { }

      constexpr basic_string_view(const _CharT* __str, size_type __len)
      : _M_len{__len}, _M_str{__str}
      { }

      basic_string_view&
      operator=(const basic_string_view&) noexcept = default;

      // [string.view.iterators], iterators

      constexpr const_iterator
      begin() const noexcept
      { return this->_M_str; }

      constexpr const_iterator
      end() const noexcept
      { return this->_M_str + this->_M_len; }

      constexpr const_iterator
      cbegin() const noexcept
      { return this->_M_str; }

      constexpr const_iterator
      cend() const noexcept
      { return this->_M_str + this->_M_len; }

      const_reverse_iterator
      rbegin() const noexcept;

      const_reverse_iterator
      rend() const noexcept;

      const_reverse_iterator
      crbegin() const noexcept;

      const_reverse_iterator
      crend() const noexcept;

      // [string.view.capacity], capacity

      constexpr size_type
      size() const noexcept
      { return this->_M_len; }

      constexpr size_type
      length() const noexcept
      { return _M_len; }

      constexpr size_type
      max_size() const noexcept
      { return this->_M_len; }

      constexpr bool
      empty() const noexcept
      { return this->_M_len == 0; }

      // [string.view.access], element access

      constexpr const _CharT&
      operator[](size_type __pos) const
      { return *(this->_M_str + __pos); }

      constexpr const _CharT&
      at(size_type __pos) const
      { return *(this->_M_str + __pos); } // THROW

      constexpr const _CharT&
      front() const
      { return *this->_M_str; }

      constexpr const _CharT&
      back() const
      { return *(this->_M_str + this->_M_len); } // CHECK!!!

      constexpr const _CharT*
      data() const noexcept
      { return this->_M_str; }

      // [string.view.modifiers], modifiers:
      void
      clear() noexcept
      { this->_M_len = 0; }

      void
      remove_prefix(size_type __n)
      { this->_M_str += __n; }

      void
      remove_suffix(size_type __n)
      { this->_M_len -= __n; }

      void
      swap(basic_string_view& __sv) noexcept
      {
	swap(this->_M_len, __sv._M_len);
	swap(this->_M_str, __sv._M_str);
      }

      // [string.view.ops], string operations:
      template<typename _Allocator>
        explicit operator basic_string<_CharT, _Traits, _Allocator>() const
        { return basic_string<_CharT, _Traits, _Allocator>(this->_M_len, this->_M_str); }

      size_type copy(_CharT* s, size_type n, size_type pos = 0) const;

      // [string.view.ops], string operations:
      constexpr basic_string_view substr(size_type pos, size_type n=npos) const;
      int compare(basic_string_view s) const noexcept;
      int compare(size_type pos1, size_type n1, basic_string_view s) const;
      int compare(size_type pos1, size_type n1,
		  basic_string_view s, size_type pos2, size_type n2) const;
      int compare(const _CharT* s) const noexcept;
      int compare(size_type pos1, size_type n1, const charT* s) const;
      int compare(size_type pos1, size_type n1,
		  const charT* s, size_type n2) const;
      size_type find(basic_string_view s, size_type pos=0) const noexcept;
      size_type find(_CharT c, size_type pos=0) const noexcept;
      size_type find(const charT* s, size_type pos, size_type n) const;
      size_type find(const _CharT* s, size_type pos=0) const noexcept;
      size_type rfind(basic_string_view s, size_type pos=0) const noexcept;
      size_type rfind(_CharT c, size_type pos=0) const noexcept;
      size_type rfind(const charT* s, size_type pos, size_type n) const;
      size_type rfind(const _CharT* s, size_type pos=0) const noexcept;
      size_type find_first_of(basic_string_view s, size_type pos=0) const noexcept;
      size_type find_first_of(_CharT c, size_type pos=0) const noexcept;
      size_type find_first_of(const charT* s, size_type pos, size_type n) const;
      size_type find_first_of(const _CharT* s, size_type pos=0) const noexcept;
      size_type find_last_of(basic_string_view s, size_type pos=0) const noexcept;
      size_type find_last_of(_CharT c, size_type pos=0) const noexcept;
      size_type find_last_of(const charT* s, size_type pos, size_type n) const;
      size_type find_last_of(const _CharT* s, size_type pos=0) const noexcept;
      size_type find_first_not_of(basic_string_view s, size_type pos=0) const noexcept;
      size_type find_first_not_of(_CharT c, size_type pos=0) const noexcept;
      size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
      size_type find_first_not_of(const _CharT* s, size_type pos=0) const noexcept;
      size_type find_last_not_of(basic_string_view s, size_type pos=0) const noexcept;
      size_type find_last_not_of(_CharT c, size_type pos=0) const noexcept;
      size_type find_last_not_of(const charT* s, size_type pos, size_type n) const;
      size_type find_last_not_of(const _CharT* s, size_type pos=0) const noexcept;

    private:
      const size_t _M_len;
      const _CharT* _M_str;
    };

  // [string.view.comparison], non-member basic_string_view comparison functions
  template<typename _CharT, typename _Traits>
    bool
    operator==(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) == 0; }

  template<typename _CharT, typename _Traits>
    bool
    operator!=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return !(__x == __y); }

  template<typename _CharT, typename _Traits>
    bool
    operator< (basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { lhs.compare(rhs) < 0; }

  template<typename _CharT, typename _Traits>
    bool
    operator> (basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { lhs.compare(rhs) > 0; }

  template<typename _CharT, typename _Traits>
    bool
    operator<=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { lhs.compare(rhs) <= 0; }

  template<typename _CharT, typename _Traits>
    bool
    operator>=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { lhs.compare(rhs) >= 0; }

  // [string.view.comparison], sufficient additional overloads of comparison functions

  // [string.view.nonmem], other non-member basic_string_view functions
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Allocator = allocator<_CharT>>
    basic_string<_CharT, _Traits, _Allocator>
    to_string(basic_string_view<_CharT, _Traits>,
	      const _Allocator& a = _Allocator());

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
      operator<<(basic_ostream<_CharT, _Traits>& os,
                 basic_string_view<_CharT,_Traits> str);

  // basic_string_view typedef names
  using string_view = basic_string_view<char>;
  using u16string_view = basic_string_view<char16_t>;
  using u32string_view = basic_string_view<char32_t>;
  using wstring_view = basic_string_view<wchar_t>;

  // [string.view.hash], hash support:
  template<typename _Tp>
    struct hash;

  template<>
    struct hash<string_view>;

  template<>
    struct hash<u16string_view>;

  template<>
    struct hash<u32string_view>;

  template<>
    struct hash<wstring_view>;

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif // _GLIBCXX_STRING_VIEW
