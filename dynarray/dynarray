#include <stdexcept>
#include <memory>

namespace std {

  template<typename _Tp> // DefaultConstructible _Tp
    struct dynarray
    {
      // types:
      using value_type             = _Tp;
      using reference              = _Tp&;
      using const_reference        = const _Tp&;
      using pointer                = _Tp*;
      using const_pointer          = const _Tp*;
      using iterator               = _Tp*;
      using const_iterator         = const _Tp*;
      using reverse_iterator       = std::reverse_iterator<iterator>;
      using const_reverse_iterator = std::reverse_iterator<const_iterator>;
      using size_type              = size_t;
      using difference_type        = ptrdiff_t;

    private:

      // fields:
      size_type _M_count;
      pointer   _M_store;

      // helper functions:
      void
      _M_check(size_type __num)
      {
	if (__num >= this->_M_count)
	  throw std::out_of_range("dynarray");
      }

      [[gnu::always_inline]]
      pointer
      _M_allocate(size_type __num)
      {
	return
	  reinterpret_cast<pointer>(alloca(__num * sizeof(value_type)));
      }

      [[gnu::always_inline]]
      void
      _M_deallocate()
      {
        //delete[] this->_M_store;
      }

      dynarray() = delete;

    public:

      // construct and destruct:
      [[gnu::always_inline]]
      explicit dynarray(size_type __num)
      : _M_count{__num},
	_M_store{this->_M_allocate(__num)}
      {
        size_type __i;
        try
        {
          for (__i = 0; __i < _M_count; ++__i)
            ::new(this->_M_store + __i) value_type;
        }
        catch ( ... )
        {
          for (; __i > 0; --__i)
            (this->_M_store + (__i - 1))->~value_type();
          throw;
        }
      }

//      template<typename _Alloc>
//	dynarray(size_type __num, const _Alloc& __alloc);

      [[gnu::always_inline]]
      dynarray(size_type __num, const value_type& __val)
      : _M_count{__num},
	_M_store{this->_M_allocate(__num)}
      {
        size_type __i;
        try
        {
          for (__i = 0; __i < _M_count; ++__i)
            ::new(this->_M_store + __i) value_type{__val};
        }
        catch ( ... )
        {
          for (; __i > 0; --__i)
            (this->_M_store + (__i - 1))->~value_type();
          throw;
        }
      }

//      template<typename _Alloc>
//	dynarray(size_type __num, const T& __val, const _Alloc& __alloc);

      [[gnu::always_inline]]
      dynarray(const dynarray& __dyna)
      : _M_count{__dyna._M_count},
	_M_store{_M_allocate(__dyna._M_count)}
      {
        try
        {
          std::uninitialized_copy(__dyna.begin(), __dyna.end(), this->begin());
        }
        catch (...)
        {
          _M_deallocate();
          throw;
        }
      }

//      template<typename _Alloc>
//	dynarray(const dynarray& __dyna, const _Alloc& __alloc);

      [[gnu::always_inline]]
      dynarray(initializer_list<value_type> __il)
      : _M_count{__il.size()},
	_M_store{_M_allocate(__il.size())}
      {
        value_type* __data = this->data();
        auto __src = __il.begin();
        for (size_type __i = 0; __i < this->_M_count; ++__i, ++__data, ++__src )
          ::new(__data) value_type(*__src);
      }

//      template<typename _Alloc>
//	dynarray(std::initializer_list<value_type>, const _Alloc& __alloc);

      ~dynarray()
      {
        for (size_type __i = 0; __i < this->_M_count; ++__i)
          (this->_M_store + __i)->~value_type();
        _M_deallocate();
      }

      const dynarray operator=(const dynarray&) = delete;

      // iterators:
      iterator
      begin() noexcept
      { return this->_M_store; }

      const_iterator
      begin() const noexcept
      { return this->_M_store; }

      const_iterator
      cbegin() const noexcept
      { return this->_M_store; }

      iterator
      end() noexcept
      { return this->_M_store + this->_M_count; }

      const_iterator
      end() const noexcept
      { return this->_M_store + this->_M_count; }

      const_iterator
      cend() const noexcept
      { return this->_M_store + this->_M_count; }

      reverse_iterator
      rbegin() noexcept  
      { return reverse_iterator(this->end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return reverse_iterator(this->end()); }

      const_reverse_iterator
      crbegin() const noexcept
      { return reverse_iterator(this->end()); }

      reverse_iterator
      rend()  noexcept
      { return reverse_iterator(this->begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return reverse_iterator(this->begin()); }

      const_reverse_iterator
      crend() const noexcept
      { return reverse_iterator(this->begin()); }

      // capacity:
      size_type
      size() const noexcept
      { return this->_M_count; }

      size_type
      max_size() const noexcept
      { return this->_M_count; }

      bool
      empty() const noexcept
      { return this->_M_count == 0; }

      // element access:
      reference
      operator[](size_type __n)
      { return this->_M_store[__n]; }

      const_reference
      operator[](size_type __n) const
      { return this->_M_store[__n]; }

      reference
      front()
      { return this->_M_store[0]; }

      const_reference
      front() const
      { return this->_M_store[0]; }

      reference
      back()
      { return this->_M_store[this->_M_count - 1]; }

      const_reference
      back() const
      { return this->_M_store[this->_M_count - 1]; }

      const_reference
      at(size_type __n) const
      {
        this->_M_check(__n);
        return this->_M_store[__n];
      }

      reference
      at(size_type __n)
      {
        this->_M_check(__n);
        return this->_M_store[__n];
      }

      // data access:
      pointer
      data() noexcept
      { return this->_M_store; }

      const_pointer
      data() const noexcept
      { return this->_M_store; }

      // mutating member functions:
      void
      fill(const value_type& __val)
      {
	for (size_type __i = 0; __i < this->_M_count; ++__i)
	  this->_M_store[__i] = __val;
      }
    };

} // namespace std

