#include <string>        // std::basic_string
#include <system_error>  // std::error_code
#include <iosfwd>        // std::basic_istream, std::basic_ostream
#include <iterator>      // std::iterator_traits
#include <memory>        // std::allocator
#include <optional>      // std::optional

namespace std {
namespace experimental {

  // class declarations
  class uri;
  class uri_builder;
  class uri_syntax_error;
  class base_uri_error;
  class uri_builder_error;
  class percent_decoding_error;

  enum class uri_error
  {
    // uri syntax errors
    invalid_syntax = 1,

    // uri reference and resolution errors
    base_uri_is_empty,
    base_uri_is_not_absolute,
    base_uri_is_opaque,
    base_uri_does_not_match,

    // builder errors
    invalid_uri,
    invalid_scheme,
    invalid_user_info,
    invalid_host,
    invalid_port,
    invalid_path,
    invalid_query,
    invalid_fragment,

    // decoding errors
    not_enough_input,
    non_hex_input,
    conversion_failed,
  };

  // factory functions
  template<typename Source>
    uri make_uri(const Source& source, std::error_code& e) noexcept;
  template<typename InputIterator>
    uri make_uri(InputIterator first, InputIterator last, std::error_code& e) noexcept;
  template<typename Source, typename Alloc>
    uri make_uri(const Source& source, const Alloc& alloc, std::error_code& e) noexcept;
  template<typename InputIterator, typename Alloc>
    uri make_uri(InputIterator first, InputIterator last, const Alloc& alloc,
                 std::error_code& e) noexcept;

  // equality and comparison operators
  bool operator==(const uri& lhs, const uri& rhs) noexcept;
  bool operator!=(const uri& lhs, const uri& rhs) noexcept;
  bool operator< (const uri& lhs, const uri& rhs) noexcept;
  bool operator> (const uri& lhs, const uri& rhs) noexcept;
  bool operator<=(const uri& lhs, const uri& rhs) noexcept;
  bool operator>=(const uri& lhs, const uri& rhs) noexcept;

  // stream operators
  template<typename CharT, typename CharTraits = std::char_traits<CharT>>
    std::basic_ostream<CharT, CharTraits>&
    operator<< (std::basic_ostream<CharT, CharTraits>& os, const uri& u);
  template<typename CharT, typename CharTraits = std::char_traits<CharT>>
    std::basic_istream<CharT, CharTraits>&
    operator>> (std::basic_istream<CharT, CharTraits>& is, uri& u);

  // swap functions
  void swap(uri& lhs, uri& rhs) noexcept;

} // namespace experimental

  // hash
  template<>
    struct hash<experimental::uri>
    {
      size_t operator()(const experimental::uri &u) const;
    };

  template<>
    struct is_error_code_enum<experimental::uri_error> : public true_type
    { };

} // namespace std

namespace std {
namespace experimental {

  class uri
  {

  public:

    // typedefs
    typedef *unspecified* string_type;
    typedef *unspecified* iterator;
    typedef *unspecified* const_iterator;
    typedef std::iterator_traits<iterator>::value_type value_type;
    typedef basic_string_view<value_type> string_view;

    // constructors and destructor
    uri();
    template<typename Source, typename Alloc = std::allocator<value_type>>
      explicit uri(const Source& source, const Alloc& alloc = Alloc());
    template<typename InputIterator, typename Alloc = std::allocator<value_type>>
      uri(InputIterator first, InputIterator last, const Alloc& alloc = Alloc());
    uri(const uri& other);
    uri(uri&& other) noexcept;
    ~uri() noexcept;

    // assignment
    uri& operator=(const uri& other);
    uri& operator=(uri&& other) noexcept;

    // modifiers
    void swap(uri& other) noexcept;

    // iterators
    const_iterator begin() const;
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    // accessors
    std::optional<string_view> scheme() const noexcept;
    std::optional<string_view> user_info() const noexcept;
    std::optional<string_view> host() const noexcept;
    std::optional<string_view> port() const noexcept;
    template<typename IntT>
      std::optional<IntT> port(typename std::is_integral<IntT>::type* = 0) const noexcept;
    std::optional<string_view> path() const noexcept;
    std::optional<string_view> authority() const noexcept;
    std::optional<string_view> query() const noexcept;
    std::optional<string_view> fragment() const noexcept;

    // string accessors
    template<typename CharT,
             typename CharTraits = std::char_traits<CharT>,
             typename Alloc = std::allocator<CharT>>
    std::basic_string<CharT, CharTraits, Alloc> string(const Alloc& alloc = Alloc()) const;
    std::string string() const;
    std::wstring wstring() const;
    std::string u8string() const;
    std::u16string u16string() const;
    std::u32string u32string() const;

    // query
    bool empty() const noexcept;
    bool is_absolute() const noexcept;
    bool is_opaque() const noexcept;

    // transformers
    uri make_relative(const uri& base) const;
    template<typename Alloc>
      uri make_relative(const uri& base, const Alloc& alloc) const;
    uri make_relative(const uri& base, std::error_code& ec) const noexcept;
    template<typename Alloc>
      uri make_relative(const uri& base, const Alloc& alloc, std::error_code& ec) const noexcept;

    uri resolve(const uri& other) const;
    template<typename Alloc>
      uri resolve(const uri& other, const Alloc& alloc) const;
    uri resolve(const uri& other, std::error_code& ec) const noexcept;
    template<typename Alloc>
      uri resolve(const uri& other, const Alloc& alloc, std::error_code& ec) const noexcept;

    // comparison
    int compare(const uri& other, uri_normalization_level level) const noexcept;

    // percent encoding and decoding
    template<typename InputIterator, typename OutputIterator>
      static OutputIterator encode_user_info(InputIterator first, InputIterator last,
                                             OutputIterator out);
    template<typename InputIterator, typename OutputIterator>
      static OutputIterator encode_host(InputIterator first, InputIterator last,
                                        OutputIterator out);
    template<typename InputIterator, typename OutputIterator>
      static OutputIterator encode_port(InputIterator first, InputIterator last,
                                        OutputIterator out);
    template<typename InputIterator, typename OutputIterator>
      static OutputIterator encode_path(InputIterator first, InputIterator last,
                                        OutputIterator out);
    template<typename InputIterator, typename OutputIterator>
      static OutputIterator encode_query(InputIterator first, InputIterator last,
                                         OutputIterator out);
    template<typename InputIterator, typename OutputIterator>
      static OutputIterator encode_fragment(InputIterator first, InputIterator last,
                                            OutputIterator out);
    template<typename InputIterator, typename OutputIterator>
      static OutputIterator decode(InputIterator first, InputIterator last,
                                   OutputIterator out);

  };


  class uri_builder
  {

  private:

    uri_builder(const uri_builder&) = delete;
    uri_builder& operator = uri_builder(const uri_builder&) = delete;

  public:

    // Constructors
    uri_builder();
    explicit uri_builder(const uri& base);
    template<typename Source>
      explicit uri_builder(const Source& base);
    template<typename InputIterator>
      uri_builder(InputIterator begin, InputIterator end);
    uri_builder(const uri_builder& other);
    uri_builder(uri_builder&& other) noexcept;
    ~uri_builder();

    // Setters
    template<typename Source>
      uri_builder& scheme(const Source& scheme);
    template<typename InputIterator>
      uri_builder& scheme(InputIterator begin, InputIterator end);
    template<typename Source>
      uri_builder& user_info(const Source& user_info);
    template<typename InputIterator>
      uri_builder& user_info(InputIterator begin, InputIterator end);
    template<typename Source>
      uri_builder& host(const Source& host);
    template<typename InputIterator>
      uri_builder& host(InputIterator begin, InputIterator end);
    template<typename Source>
      uri_builder& port(const Source& port);
    template<typename InputIterator>
      uri_builder& port(InputIterator begin, InputIterator end);
    template<typename Source>
      uri_builder& authority(const Source& authority);
    template<typename InputIterator>
      uri_builder& authority(InputIterator begin, InputIterator end);
    template<typename UserInfoSource, typename HostSource, PortSource>
      uri_builder& authority(const UserInfoSource& user_info,
                             const HostSource& host, const PortSource& port);
    template<typename Source>
      uri_builder& path(const Source& path);
    template<typename InputIterator>
      uri_builder& path(InputIterator begin, InputIterator end);
    template<typename Source>
      uri_builder& append_path(const Source& path);
    template<typename InputIterator>
      uri_builder& append_path(InputIterator begin, InputIterator end);
    template<typename Source>
      uri_builder& query(const Source& query);
    template<typename InputIterator>
      uri_builder& query(InputIterator begin, InputIterator end);
    template<typename Key, typename Param>
      uri_builder& append_query(const Key& key, const Param& param);
    template<typename Source>
      uri_builder& fragment(const Source& fragment);
    template<typename InputIterator>
      uri_builder& fragment(InputIterator begin, InputIterator end);

    // Builder
    std::experimental::uri uri() const;

  };


  class uri_syntax_error : public std::system_error
  {
  public:
    uri_syntax_error(const string& what_arg, error_code ec);
    virtual ~uri_syntax_error() noexcept;
    virtual const char *what() const noexcept;
  };


  class base_uri_error : public std::system_error
  {
  public:
    base_uri_error(const string& what_arg, error_code ec);
    virtual ~base_uri_error() noexcept;
    virtual const char *what() const noexcept;
  };


  class uri_builder_error : public std::system_error
  {
  public:
    uri_builder_error(const string& what_arg, error_code ec);
    virtual ~uri_builder_error() noexcept;
    virtual const char *what() const noexcept;
  };


  class percent_decoding_error : public std::system_error
  {
  public:
    percent_decoding_error(const string& what_arg, error_code ec);
    virtual ~percent_decoding_error() noexcept;
    virtual const char *what() const noexcept;
  };


} // namespace experimental
} // namespace std
