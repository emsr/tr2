//  https://gist.github.com/lichray/6034753

#include <array>
#include <functional>
 
template<typename... _T>
  using common_type_t = typename std::common_type<_T...>::type;
 
template<typename _T>
  using remove_cv_t = typename std::remove_cv<_T>::type;
 
template<bool, typename _T, typename... _U>
  struct lazy_conditional_c;
 
template<typename _T>
  struct lazy_conditional_c<true, _T>
  {
    using type = typename _T::type;
  };
 
template<typename _T, typename _U>
  struct lazy_conditional_c<true, _T, _U>
  {
    using type = typename _T::type;
  };
 
template<typename _T, typename _U>
  struct lazy_conditional_c<false, _T, _U>
  {
    using type = typename _U::type;
  };
 
template<typename _V, typename _T, typename... _U>
  using If = lazy_conditional_c<_V::value, _T, _U...>;
 
template<typename _V, typename _T, typename... _U>
  using If_t = typename If<_V, _T, _U...>::type;
 
template<typename _T>
  struct identity_of
  {
    using type = _T;
  };
 
template<template<typename> class _F, typename... _T>
  struct no_type
  : std::true_type
  {};
 
template<template<typename> class _F, typename _T1, typename... _T2>
  struct no_type<_F, _T1, _T2...>
  : std::integral_constant<bool, not F<_T1>::value and no_type<_F, _T2...>::value>
  {};
 
template<template<typename> class _F, template<typename> class _G>
  struct composed
  {
    template<typename _T>
      using call = _F<typename _G<_T>::type>;
  };
 
template<typename _T>
  struct _is_reference_wrapper : std::false_type {};
 
template<typename _T>
  struct _is_reference_wrapper<std::reference_wrapper<_T>> : std::true_type {};
 
template<typename _T>
  using is_reference_wrapper =
  composed<_is_reference_wrapper, std::remove_cv>::call<_T>;
 
template<typename... _T>
  constexpr auto
  make_array(_T&&... __t)
  -> std::array<_If_t<no_type<composed<is_reference_wrapper, std::remove_reference>::call, _T...>,
              std::common_type<_T...>>, sizeof...(_T)>
  {
    return {{ std::forward<_T>(__t)... }};
  }
 
template<typename _V, typename... _T>
  constexpr auto
  make_array(_T&&... __t)
  -> std::array<_V, sizeof...(_T)>
  {
    return {{ std::forward<_T>(__t)... }};
  }
 
template<size_t... _I>
  struct _indices {};
 
template<size_t _N, size_t... _I>
  struct _build_indices
  : _build_indices<N - 1, _N - 1, _I...>
  {};

template<size_t... _I>
  struct _build_indices<0, _I...>
  : _indices<_I...>
  {};
 
template<typename _T, size_t _N, size_t... _I>
  constexpr auto
  _to_array(_T (&__arr)[_N], _indices<_I...>)
  -> std::array<remove_cv_t<_T>, _N>
  {
    return {{ __arr[_I]... }};
  }
 
template<typename _T, size_t _N>
  constexpr auto
  to_array(_T (&__arr)[_N])
  -> std::array<remove_cv_t<_T>, _N>
  {
    return _to_array(__arr, _build_indices<_N>());
  }
